/**
 * This file provided by Facebook is for non-commercial testing and evaluation
 * purposes only. Facebook reserves all rights not expressly granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

var React = require('react');
var ReactRedux = require('react-redux');
var marked = require('marked');

var Comment = React.createClass({
  rawMarkup: function() {
    var rawMarkup = marked(this.props.children.toString(), {sanitize: true});
    return { __html: rawMarkup };
  },

  render: function() {
    var statusLabel = null;
    if(this.props.status == 'offline') {
      statusLabel = <div className="status">offline</div>
    }
    var deleteButton = null;
    if(this.props.netStatus == 'static' || this.props.netStatus == 'online') {
      deleteButton = <form method="post" action={"/api/comments/delete/"+this.props.commentID} onSubmit={this.props.deleteComment} className="delete"><input type="submit" value="Delete" /></form>
    } else if(this.props.status == "offline") {
      deleteButton = <button onClick={this.props.deleteOfflineComment} className="delete">Delete</button>
    }
    var spinner = null;
    if(this.props.status == "adding" || this.props.status == "deleting") {
      spinner = <img className="spinner" src="img/spin.gif" />
    }
    return (
      <div className={"comment"+" "+this.props.status}>
        {statusLabel}
        {deleteButton}
        <h2 className="commentAuthor">
          {this.props.author}
          {spinner}
        </h2>
        <span dangerouslySetInnerHTML={this.rawMarkup()} />
      </div>
    );
  }
});

var CommentBox = React.createClass({
  handleCommentSubmit: function(comment) {
    // Optimistically set an id on the new comment. It will be replaced by an
    // id generated by the server. In a production application you would likely
    // not use Date.now() for this and would have a more robust system in place.

    this.props.addComment(comment);
  },
  render: function() {
    return (
      <div className="commentBox">
        <h1>Comments</h1>
        <CommentList />
        <CommentForm onCommentSubmit={this.handleCommentSubmit} />
      </div>
    );
  }
});

var CommentList = React.createClass({
  render: function() {
    var commentNodes = this.props.data.map(function(comment) {
      return (
        <Comment author={comment.author} commentID={comment.id} status={comment.status} key={comment.id}>
          {comment.text}
        </Comment>
      );
    });
    return (
      <div className="commentList">
        {commentNodes}
      </div>
    );
  }
});

var CommentForm = React.createClass({
  getInitialState: function() {
    /* Enable button if browser JS disabled */
    return {enablePost: true}
  },
  componentDidMount: function() {
    this.setState({enablePost: false})
  },
  componentWillReceiveProps: function(nextProps) {
    this.setState({enablePost: Boolean(nextProps.newComment.author.trim() && nextProps.newComment.text.trim())})
  },
  handleSubmit: function(e) {
    e.preventDefault();
    var author = this.props.newComment.author.trim();
    var text = this.props.newComment.text.trim();
    if (!text || !author) {
      return;
    }
    this.authorInput.blur(); this.textInput.blur();
    this.props.onCommentSubmit({author: author, text: text});
    this.props.clearInput();
  },
  render: function() {
    var _this = this;
    return (
      <form className="commentForm" method="post" action={this.props.url} onSubmit={this.handleSubmit}>
        <input
          type="text"
          name="author"
          placeholder="Your name"
          autoComplete="off"
          ref={function(input) { _this.authorInput = input; }}
          value={this.props.newComment.author}
          onChange={this.props.handleAuthorChange}
        />
        <input
          type="text"
          name="text"
          placeholder="Say something..."
          autoComplete="off"
          ref={function(input) { return _this.textInput = input; }}
          value={this.props.newComment.text}
          onChange={this.props.handleTextChange}
        />
		<input type="submit" value="Post" disabled={!this.state.enablePost} />
      </form>
    );
  }
});

var CommentBoxDispatch = function(dispatch) {
  return {
    addComment: function(comment) {
      comment.id = Date.now();
      dispatch({
        type: 'add_comment',
        comment: comment,
      })
    },
  }
}

var CommentListState = function(state) {
  return {
    data: state.data.concat(state.offlinedata)
  }
}

var CommentFormState = function(state) {
  return {
    url: state.url,
    newComment: state.newComment
  }
}

var CommentFormDispatch = function(dispatch) {
  return {
    handleAuthorChange: function(e) {
      dispatch({
        type: 'author_change',
        author: e.target.value
      })
    },
    handleTextChange: function(e) {
      dispatch({
        type: 'text_change',
        text: e.target.value
      })
    },
    clearInput: function() {
      dispatch({type: 'clear_input'});
    }
  }
}

var CommentState = function(state) {
  return {
    netStatus: state.netStatus
  }
}

var CommentDispatch = function(dispatch, ownProps) {
  return {
    deleteComment: function(e) {
      e.preventDefault();
      dispatch({
        type: 'delete_comment',
        commentID: ownProps.commentID
      })
    },
    deleteOfflineComment: function() {
      dispatch({
        type: 'delete_offline_comment',
        commentID: ownProps.commentID
      })
    }
  }
}

var connect = ReactRedux.connect;

CommentBox = connect(
  null,
  CommentBoxDispatch
)(CommentBox)
CommentList = connect(
  CommentListState
)(CommentList)
CommentForm = connect(
  CommentFormState,
  CommentFormDispatch
)(CommentForm)
Comment = connect(
  CommentState,
  CommentDispatch
)(Comment)

module.exports = CommentBox;
